### **引言**
昨天，我們完成排序演算法的動畫架構，接下來，讓我們把各種排序方法一一植入，製作逐格動畫！


### 快速排序
這個快速排序實現是基於遞迴的經典版。它將最後一個元素選作樞軸 (pivot)，並將陣列分為兩部分：較小的元素放在左邊，較大的元素放在右邊。然後對兩部分遞迴進行相同的操作。
```javascript
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    const pivot = arr[arr.length - 1];
    const left = [];
    const right = [];
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] < pivot) left.push(arr[i]);
        else right.push(arr[i]);
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
```
這種實現的優點是易於理解和編寫，直接使用遞迴的方式解決問題。但缺點在於它需要額外的空間來存儲每次遞迴的左右陣列
#### 迭代方程式
這一版本使用一個模擬遞迴的方式，通過 stack 來保存要處理的子陣列範圍，並手動管理 pivot 的移動和分區過程，避免了遞迴調用，對記憶體非常友善。

```javascript
class SortAlgorithm{
    quickSortSetting(columns){
        this.stack = [{'left': 0, 'right': columns.length - 1}];
        this.partitionPhase = "0.SetPivot";
        this.pivot = Math.floor(columns.length - 1);
        this.j = 0;
    }
    quickSort(columns){
        const len = this.stack.length;
        const {left, right} = this.stack[len - 1];
        const pivot = this.pivot;
        const frame = 60;
        switch(this.partitionPhase){
            case "0.SetPivot":
                const a = columns[Math.floor((left + right) / 2)];
                const b = columns[right];
                SortAlgorithm.swapColumn(a, b, frame);
                this.leftBound = left;
                this.rightBound = right - 1;
                this.pivot = right;
                this.partitionPhase = "1.FindLeftBound";
                this.j = 0;
                break;
            case "1.FindLeftBound":
                if(columns[this.leftBound + this.j].height >= columns[pivot].height){
                    this.leftBound = this.leftBound + this.j;
                    this.partitionPhase = "2.FindRightBound";
                    this.j = 0;
                    break;
                }
                this.j++;
                break;
            case "2.FindRightBound":
                if(columns[pivot].height >= columns[this.rightBound - this.j].height || this.rightBound - this.j <= this.leftBound){
                    this.rightBound = this.rightBound - this.j;
                    this.partitionPhase = "3.SwapBoth";
                    break;
                }
                this.j++;
                break;
            case "3.SwapBoth":
                if(this.leftBound < this.rightBound){
                    const a = columns[this.leftBound];
                    const b = columns[this.rightBound];
                    SortAlgorithm.swapColumn(a, b, frame);
                    this.partitionPhase = "1.FindLeftBound"
                    this.j = 0;
                    this.leftBound++;
                    this.rightBound--;
                }
                else{
                    const a = columns[this.leftBound];
                    const b = columns[pivot];
                    SortAlgorithm.swapColumn(a, b, frame);
                    this.partitionPhase = "4.EndPartition";
                    this.pivot = this.leftBound;
                }
                break;
            case "4.EndPartition":
                this.stack.pop();
                if(left < pivot - 1) this.stack.push({'left': left, 'right': pivot - 1});
                if(pivot + 1 < right) this.stack.push({'left': pivot + 1, 'right': right});
                if(this.stack.length == 0) return true;
                this.partitionPhase = "0.SetPivot";
                break;
            default:
        }
    }
}
```
* step0：把 pivot 移到右邊
* step1：輸入 left, right - 1
* step2：找到 leftBound
* step3：找到 rightBound
* step4：循環 > 交換並輸入leftBound, rightBound
* step5：跳出循環 > 定位 pivot

它模擬了遞迴，利用棧來記錄子區間。每個子區間在分割後不會創建新的陣列，優化了空間使用。分區過程被分解為幾個步驟，並且允許在每步中進行動畫展示。

#### 迭代器和生成器
這個版本利用生成器來實現快速排序，讓排序過程可以逐步進行，適合動畫的逐幀展示。

```javascript
class SortAlgorithmIterable{
    * quickSortMaker(columns, left = 0, right = columns.length - 1) {
        yield false;
        if (left >= right) return;
        const pivotIndex = yield* SortAlgorithm.partition(columns, left, right);
        yield* this.quickSortMaker(columns, left, pivotIndex - 1);
        yield* this.quickSortMaker(columns, pivotIndex + 1, right);
        if(left == 0 && right == columns.length - 1) yield true;
    }
    static* partition(columns, left, right) {
        const pivot = columns[right];
        let i = left;
        for (let j = left; j < right; j++) {
            yield false;
            if (columns[j].height < pivot.height) {
                SortAlgorithm.swapColumn(columns[i], columns[j], 30);
                i++;
            }
        }
        SortAlgorithm.swapColumn(columns[i], columns[right], 30);
        return i;
    }
}
```


### **結論**
