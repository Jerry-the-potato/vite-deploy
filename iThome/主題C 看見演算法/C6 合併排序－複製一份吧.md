### **引言**
昨天，我們完成排序演算法的動畫架構，接下來，讓我們把各種排序方法一一植入，製作逐格動畫！


### 合併排序

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    return merge(left, right);
}

function merge(left, right) {
    let result = [];
    while (left.length && right.length) {
        if (left[0] < right[0]) result.push(left.shift());
        else result.push(right.shift());
    }
    return [...result, ...left, ...right];
}

```

#### 迭代方程式

```javascript
class SortAlgorithm{
    mergeSortSetting(columns){
        const heights = columns.map((column)=>{return column.height});
        this.height = Math.max(...heights);
        this.stack = [[], []];
        this.stack[0][0] = {'left': 0, 'right': columns.length - 1};
        this.mergePhase = "0.Split";
        this.i = 0;
        this.j = 0;
    }
    mergeSort(columns) {
        const len0 = this.stack[0].length;
        const len1 = this.stack[1].length;
        const {min, mid, max} = this.stack[1][len1 - 1] ? this.stack[1][len1 - 1] : {};
        const i = this.i;
        const j = mid - min + this.j;
        const col = this.secondColumns.slice(min, max + 1);
        const frame = Math.min(30 + Math.floor((max - j + mid - i)/(len0 + len1)), 90);
        // const frame = Math.floor((max - j + mid - i)/(len/256));
        switch(this.mergePhase){
            case "0.Split":
                if(len0 == 0){
                    this.mergePhase = "1.Copy";
                    this.timesEveryFrame = 1;
                    this.secondColumns = JSON.parse(JSON.stringify(columns.slice(0, columns.length + 1)));
                    this.secondColumns.forEach((column) => {
                        column.path = new Path(column.x, column.y);
                        column.path.NewTarget(column.x, column.y - this.height, 20);
                        column.width/=3;
                    })
                    return;
                }
                const { left, right } = this.stack[0][len0 - 1];
                const middle = Math.ceil((left + right) / 2);
                this.stack[0].pop();
                if(left != right){
                    this.stack[0].push({'left': left, 'right': middle - 1});
                    this.stack[0].push({'left': middle, 'right': right});
                    this.stack[1].push({'min': left, 'mid': middle, 'max': right});
                }
                break;
            case "1.Copy":
                if(len1 == 0){
                    return true;
                }
                col.forEach((column, index) => {
                    column.height = columns[min + index].height;
                    column.width = columns[min + index].width/2;
                    column.path.NewTarget(column.x, column.y - this.height, 0);
                })
                this.mergePhase = "2.Merge";
                break;
            case "2.Merge":
                if(col[i].height > col[j].height){
                    const a = col[j];
                    const b = columns[min + this.i + this.j];
                    SortAlgorithm.swapColumn(a, b, frame);
                    a.height = 0;
                    this.j++;
                    if(this.j > max - mid){
                        this.mergePhase = "3.MergeLeft";
                    }
                }
                else{
                    const a = col[i];
                    const b = columns[min + this.i + this.j];
                    SortAlgorithm.swapColumn(a, b, frame);
                    a.height = 0;
                    this.i++;
                    if(this.i > mid - min){
                        this.i--;
                        this.j++;
                    }
                    if(this.i >= mid - min){
                        this.mergePhase = "4.MergeRight";
                    }
                }
                break;
            case "3.MergeLeft":
                if(i >= mid - min){
                    this.i = 0;
                    this.j = 0;
                    this.stack[1].pop();
                    if(this.stack[1].length == 0){
                        this.isStoping = true;
                        return
                    }
                    this.mergePhase = "1.Copy";
                    col.forEach((column, index) => {
                        column.height = columns[min + index].height;
                        column.path.NewTarget(column.x, column.y - this.height, 20);
                        column.width/=3;
                    })
                }
                else{
                    const a = col[i];
                    const b = columns[min + this.i + this.j];
                    SortAlgorithm.swapColumn(a, b, frame);
                    a.height = 0;
                    this.i++;
                }
                
                break;
            case "4.MergeRight":
                if(j > max - min){
                    this.i = 0;
                    this.j = 0;
                    this.stack[1].pop();
                    if(this.stack[1].length == 0){
                        this.isStoping = true;
                        return
                    }
                    this.mergePhase = "1.Copy";
                    col.forEach((column, index) => {
                        column.height = columns[min + index].height;
                        column.path.NewTarget(column.x, column.y - this.height, 20);
                        column.width/=3;
                    })
                }
                else{
                    const a = col[j];
                    const b = columns[min + this.i + this.j];
                    SortAlgorithm.swapColumn(a, b, frame);
                    a.height = 0;
                    this.j++;
                }
                break;
        }
    }
}
```

#### 迭代器和生成器

```javascript
class SortAlgorithmIterable{
    * mergeSortMaker(columns, left = 0, right = columns.length - 1) {
        if (left >= right) return;
        const mid = Math.floor((left + right) / 2);
        yield* this.mergeSortMaker(columns, left, mid);
        yield* this.mergeSortMaker(columns, mid + 1, right);
        yield* this.mergeMaker(columns, left, mid, right);
        if(left == 0 && right == columns.length - 1) yield true;
    }

    * mergeMaker(columns, left, mid, right) {
        const secondColumns = JSON.parse(JSON.stringify(columns.slice(left, right + 1)));
        const heights = secondColumns.map((column)=>{return column.height});
        const max = Math.max(...heights);
        // 為每個 column 添加 path 和動畫目標
        secondColumns.forEach((column) => {
            column.path = new Path(column.x, column.y);
            column.path.NewTarget(column.x, column.y - max, 20);
            column.width /= 3;  // 動畫效果: 將寬度縮小三分之一
        });

        let i = 0; // 左半部分的索引
        let j = mid - left + 1; // 右半部分的索引
        let k = left; // 合併後的索引

        // 合併兩個部分
        while (i <= mid - left && j <= right - left) {
            yield false;
            if (secondColumns[i].height <= secondColumns[j].height) {
                const a = columns[k];
                const b = secondColumns[i];
                SortAlgorithm.swapColumn(a, b, 30);
                i++;
            } else {
                const a = columns[k];
                const b = secondColumns[j];
                SortAlgorithm.swapColumn(a, b, 30);
                j++;
            }
            k++;
        }

        // 如果左邊有剩餘，繼續合併
        while (i <= mid - left) {
            yield false;
            const a = columns[k];
            const b = secondColumns[i];
            SortAlgorithm.swapColumn(a, b, 30);
            i++;
            k++;
        }

        // 如果右邊有剩餘，繼續合併
        while (j <= right - left) {
            yield false;
            const a = columns[k];
            const b = secondColumns[j];
            SortAlgorithm.swapColumn(a, b, 30);
            j++;
            k++;
        }
    }

}
```


### **結論**
