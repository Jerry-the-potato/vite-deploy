### **引言**
昨天，我們完成排序演算法的動畫架構，接下來，讓我們把各種排序方法一一植入，製作逐格動畫！


### 插入排序

```javascript
function insertionSort(arr) {
    const n = arr.length;
    for (let i = 1; i < n; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}

```

#### 迭代方程式

```javascript
class SortAlgorithm{
    insertionSortSetting(columns){
        this.i = 1;
        this.key = columns[1].height;
        this.j = 0;
    }
    insertionSort(columns){
        const len = columns.length;
        const i = this.i;
        const j = this.j;
        if (i < len) {
            if (j >= 0 && columns[j].height > columns[j + 1].height) {
                const a = columns[j + 1];
                const b = columns[j];
                SortAlgorithm.swapColumn(a, b, 30);
                this.j--;
            }
            else{
                
                this.i++;
                if(this.i >= len) return true;
                this.j = this.i - 1;
            }
        }
        else return true
    }
}
```

#### 迭代器和生成器

```javascript
class SortAlgorithmIterable{
    * insertionSortMaker(columns) {
        const len = columns.length;
        for (let i = 1; i < len; i++) {
            let key = columns[i].height;
            let j = i - 1;
            while (j >= 0 && columns[j].height > key) {
                const a = columns[j + 1];
                const b = columns[j];
                SortAlgorithm.swapColumn(a, b, 30);
                yield false;
                j--;
            }
        }
        yield true;
    }
}
```

### 希爾排序

```javascript
function shellSort(arr) {
    const n = arr.length;
    let gap = Math.floor(n / 2);
    while (gap > 0) {
        for (let i = gap; i < n; i++) {
            let temp = arr[i];
            let j = i;
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
        gap = Math.floor(gap / 2);
    }
    return arr;
}
```

#### 迭代方程式

```javascript
class SortAlgorithm{
    shellSortSetting(columns){
        this.gap = Math.floor(columns.length / 2);
        this.i = this.gap;
        this.j = this.i;
    }
    shellSort(columns){
        const len = columns.length;
        const gap = this.gap;
        const i = this.i;
        const j = this.j;
        if(gap > 0){
            if(i < len){
                const a = columns[j];
                const b = columns[j - gap];
                if (j >= gap && b.height > a.height) {
                    const a = columns[j];
                    const b = columns[j - gap];
                    SortAlgorithm.swapColumn(a, b, 60);
                    this.j-= gap;
                }
                else{
                    this.i++;
                    this.j = this.i;
                }
            }
            else{
                this.gap = Math.floor(gap / 2);
                this.i = this.gap;
                this.j = this.i;
            }
        }
        else return;
    }
}
```

#### 迭代器和生成器

```javascript
class SortAlgorithmIterable{
    * shellSortMaker(columns) {
        const len = columns.length;
        let gap = Math.floor(len / 2);
        while (gap > 0) {
            for (let i = gap; i < len; i++) {
                let j = i;
                while (j >= gap && columns[j - gap].height > columns[j].height) {
                    const a = columns[j];
                    const b = columns[j - gap];
                    SortAlgorithm.swapColumn(a, b, 60);
                    yield false;
                    j -= gap;
                }
            }
            gap = Math.floor(gap / 2);
        }
        yield true;
    }
}
```

### **結論**
