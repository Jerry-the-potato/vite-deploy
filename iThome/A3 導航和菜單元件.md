## 回來做元件！

今天接著介紹如何利用模板動態生成DOM，並比較 React 和 Vue 的不同實作方式。
> Functional component vs Composition API

### 架構設計
將divRef作為參數傳遞給 NavigationBar，根據子元件數量動態生成導航和 href：
```
function Playground({margin}){
    //......
    return (
        <>
            <div id="playground" ref={divRef} style={getStyle()}>
                //......
            </div>
            <NavigationBar divRef={divRef} width={(ratio == 1) ? 250 : 150}/>
        </>
    )
}
```
> 延續先前的設計，使用 ratio 來判斷是否為桌面端或移動端，調整導航欄的寬度。

### 導航欄的實作

#### React
接著利用 useState 儲存 isOpen，並在狀態變更時重新渲染導航欄：
```
function NavigationBar({width, divRef}){
    const [isOpen, setIsOpen] = useState(false);
    return  <nav id="nav" style={{
                "left": (isOpen ? 0 : -width) + "px",
                "width": width
            }}>
                <GetHyperLink divRef={divRef}></GetHyperLink>
                <div onClick={() => setIsOpen(!isOpen)} id="navSlider">
                    <p>{isOpen ? "X": "≡"}</p>
                </div>
            </nav>

}
```
> 這邊沒有用 handleClick 函數來包裹邏輯，而是直接寫在模板中，對新手來說，必須注意傳遞給事件的是一個回呼函式，event會作為這個函式的唯一參數，所以要用一個 () 來包裹 setIsOpen，其實就是 (e) => {......} 但是e沒有用到。

#### Vue
```
<script setup>
    //......
    const props = defineProps({
        width: Number,
        divRef: Object
    });
    const isOpen = ref(false);
    const handleClick = () => isOpen.value = !isOpen.value;
</script>

<template>
    <nav id="nav" :style="{left: isOpen ? '0' : -width + 'px'}">
        //......
        <div @click="handleClick" id="navSlider">
            <p>{{isOpen ? "X": "≡"}}</p>
        </div>
    </nav>
</template>
```

### 動態生成超連結
一個基本的超連結模板如下所示：
```
<a key="section1" href="#section1" >section1</a>

<a key={ID} href={"#"+ID} >{ID}</a>
```
> key 很重要，是框架用來識別唯一元素的依據，在平級之間不重複即可

那麼，透過 divRef.current 取得 playground 元件中的所有 section ，並根據它們的 ID 生成對應的超連結：

#### React
```
function GetHyperLink({divRef}){
    const [hyperlink, setHyperlink] = useState();
    useEffect(() => {
        const sections = divRef.current.getElementsByTagName("section");
        setHyperlink(Object.keys(sections).map((key) => {
            const ID = sections[key].id;
            return <a key={ID} className="list" href={"#"+ID} >{ID}</a>
        }));
    }, []);
    return hyperlink;
}
```

#### Vue


### 潛在的問題
由於我們需要超連結在副作用生成，藉此取得渲染完的元件 section，因而產生新的問題。客戶端無法利用網址後的hash，立刻跳轉到指定區塊，所以我們還需要利用副作用跳轉：
```
function handleHashChange(){
    const hash = window.location.hash;
    if (!hash) return;

    const targetElement = document.querySelector(hash);
    if (!targetElement) return;

    targetElement.scrollIntoView({ behavior: 'smooth' });
};

function NavigationBar({width, divRef}){
    useEffect(() => {
        handleHashChange();
        window.addEventListener('hashchange', handleHashChange);
        return () => {
            window.removeEventListener('hashchange', handleHashChange);
        }
    }, []);
    //......
}
```
> 渲染完元件後，會立刻執行一次跳轉到指定的區塊，同時監聽 hashchange ，藉此可以客製化更多細節，比如實現水平方向或垂直方向的對齊，詳細可以參考[MDN scrollIntoView](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView)

#### Vue 中的對應實作
另外，別忘了 removeEventListener ，在React函數式組件會利用 return 來回傳卸載元件所需的，這點我們可以跟vue的Composition API比較，看起來是不是很像類組件呢？

onMounted(() => {
    handleHashChange();
    window.addEventListener('hashchange', handleHashChange);
});

onUnmounted(() => {
    window.removeEventListener('hashchange', handleHashChange);
});

### 結語
透過這種動態生成的方式，無論未來添加多少個 canvas，我們都能自動生成對應的超連結。

動態生成的概念相當重要，這種方式廣泛應用於文章目錄、影片目錄等場景。語法本身並不困難，主要挑戰在於理解渲染的順序。希望這篇文章能為新手提供一些啟發！