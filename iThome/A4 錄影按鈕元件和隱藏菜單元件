
### 需求
在後續的開發，canvas section需要一個菜單面板，放置參數和控制鈕，內容也都不相同，那麼，重複的地方就只剩下css和UI邏輯，比方說，我們需要一個按鈕來收納整個菜單。

```
function CanvasSectionS2({ratio, min}) => {
    //......
    const menu = useRef(null);
    return (
        <section className="section" id={uniqueID}>
            <canvas width={min * ratio} height={ratio * min * ratio}></canvas>
            <div ref={menu} className="gamemenu">
                //......
                <SlideMenuBtn menu={menu}></SlideMenuBtn>
            </div>
        </section>
    );
}
```

### SlideMenuBtn 元件設計概念
按鈕點擊後，菜單會收納、隱藏，這個元件好用之處在於：
1. 它會幫助計算菜單的高度，自動收納
2. 他只需要輸入菜單
3. 也可以更改收納方向
```<SlideMenuBtn menu={menu} direction="left"></SlideMenuBtn>```

這裡，我們透過設置inline-style，讓菜單往畫面外移動，復原的時候就用空字串，使用預設的css佈局：
```
// 向上收納
m.style.top = isOpen ? "" :　"-" + positionOffset.top + "px";
// 向任意方向收納
m.style[direction] = isOpen ? "" : "-" + positionOffset[direction] + "px";
```

利用 getBoundingClientRect 計算偏移量 offset，目標是把菜單隱藏起來、露出按鈕，因此進行相減：
```
function SlideMenuBtn({menu, direction ="top"}){
    const [isOpen, setIsOpen] = useState(true);

    function handleClick(e){
        const m = menu.current; // menuElement
        const b = e.target; // buttonElement
        const menuRect  = m.getBoundingClientRect();
        const buttonRect  = b.getBoundingClientRect();
        const positionOffset = {
            "left": buttonRect.x - menuRect.x,
            "top": buttonRect.y - menuRect.y
        };
        m.style[direction] = !isOpen ? "" : "-" + positionOffset[direction] + "px";

        setIsOpen(!isOpen);
    }
    return <button onClick={handleClick} className="slideMenu">
        {isOpen ? "收起△" : "展開▽"}
    </button>;
```
> 在判斷開關的時候，我習慣用 !isOpen ，這是因為我們採用先執行後渲染的策略，因此，用渲染後的值 !isOpen 來判斷會比較直覺。

可以把這個按鈕放在右下角，收納行為分成向左和向上：
```
/* css */
.menu button.slideMenu{
    position: relative;
    float: inline-end;
}
```