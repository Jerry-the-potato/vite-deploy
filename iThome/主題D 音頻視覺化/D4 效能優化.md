### 引言


### 


### Mesh



### 架構

31.3 vs 32.5

#### 將音訊資料轉換成頂點和幾何體

```javascript
class BufferFactory{
    transformData(data){
        // 循環陣列
        const factory = this.#factorys.shift();
        this.#factorys.push(factory);
        // 計算頂點座標
        const vector = this.getPosition(data);
        const vertices = this.getVertices(vector);
        const attribute = new THREE.BufferAttribute(vertices, 3);
        factory.geometry.setAttribute('position', attribute);
        // 計算頂點顏色
        const colorVertices = this.getColorVertices(data, vertices);
        const colorAttribute = new THREE.BufferAttribute(colorVertices, 3)
        factory.geometry.setAttribute('color', colorAttribute);
    }
}
```
* THREE.BufferAttribute：透過它，我們能夠將自定義頂點數據傳遞到 WebGL 中，進行高效渲染。
* setAttribute：這實際上和 WebGL 傳遞變數的方式有關，因為 position、color 變數不存在 Javascript 環境中，所以用這個方式將數據綁定到 WebGL 繪圖上下文。

#### 長條圖的流動效果
> Youtube 影片
[![Yes](https://img.youtube.com/vi/X7remQEUWAU/0.jpg)](https://youtu.be/X7remQEUWAU)

當添加新的圖形時，我們希望它像水一樣，不斷流下去，直到中斷處消失。為達成這個效果，我們才將首個元素放入末尾，並且更新覆蓋它的圖形。接著，在每次更新時根據索引值來分配Ｚ軸座標，就能實現不斷循環更新的長條圖了。

```javascript
class BufferFactory{
    #depth = 2;
    updateFactorys(){
        const len = this.#factorys.length;
        this.#factorys.forEach((factory, index)=>{
            factory.mesh.position.set(0, 0, this.#depth * (index - len));
        });
    }
    update(){
        this.updateFactorys();
    }
}
```

### 結論
本文探討了 TypedArray 在 3D 圖形渲染中的應用，特別是如何使用 Three.js 結合 Float32Array 高效地生成和更新長條圖。透過簡單的工廠設計模式，我們成功構建了一個能夠處理實時資料的圖形渲染系統。明天，我們將詳細探討頂點和圖形的關係，你將學會如何利用頂點繪製圖形，並且完整演算法的封裝。

如果感興趣，可以參考 Github 上的原始碼：
* [musicAnalyser.js](https://github.com/Jerry-the-potato/vite-deploy/blob/main/src/js/musicAnalyser.js)
* [bufferFactory.js](https://github.com/Jerry-the-potato/vite-deploy/blob/main/src/js/bufferFactory.js)