### **引言**
在上一個主題中，我們用原生 JS 完成了基本的粒子系統和排序演算法的視覺化，然而，造輪子還是有一定的局限性，尤其是更複雜的圖形如 3D 的投影和座標轉換，因此，本文將展示如何使用 Three.js 強大的渲染器，來幫助我們簡化再三維場景中的圖形渲染。

起初做這個主題，是我看到了音頻資料的傅立葉轉換，可以用 3D 的形式看出時域和頻域的關係，不過這需要一定的理論基礎，因此我們會將眼光侷限在如何將音頻資料結合 3D 長條圖來實現。

### 架構
在這裡，和先前相同，提供前端一個控制介面：
```jsx
import musicAnalyser from '../js/musicAnalyser';
useEffect(()=>{
    musicAnalyser.setCanvas(canvas.current);
    window.addEventListener('resize', musicAnalyser.resize, false);
    return () => {
        musicAnalyser.cleanup();
        window.removeEventListener("resize", musicAnalyser.resize);
    }
}, []);
```
因為 Three 會協助我們做底層運算，將物體投影到攝影機的視角，因此我們只需要利用它的基本工具**場景**、**鏡頭**、**渲染器**，它就能幫我們把長條圖精準繪製在畫布中了！
```javascript
import * as THREE from 'three';
const createMusicAnalyser = function(){
    this.setCanvas = (canvas) => {
        this.scene = new THREE.Scene();
        this.renderer = new THREE.WebGLRenderer({"alpha": true, "canvas": canvas});
        this.camera = new THREE.PerspectiveCamera( 75, canvas.width / canvas.height, 0.1, 1000 );
    };
    this.cleanup = () => {};
    this.resize = () => {};
    this.getAnalyser = () => {};
    this.update = () => {};
    this.render = () => {
        this.renderer.render( this.scene, this.camera );
    }
    return this;
}
```
* scene
* renderer
* camera

#### 頻譜分析
在使用 Web Audio API 取得音訊資料的時候，必須經過使用者的同意或主動播放音樂，因此透過播放事件來建立
```javascript
this.firstTime = true;
this.getAnalyser = (e) => {
    const audio = e.target;
    if(this.firstTime) this.analyser = createAnalyser(audio);
    this.firstTime = false;
}

<audio onPlay={musicAnalyser.getAnalyser}></audio>
```
我們需要 AudioContext 作為接口來處理音頻資料，利用它可以調整音量、進行混音等。在這裡只示範如何取得傅立葉轉換後的資料，並且將音量設置為 1 倍大小，完整的流程如下，我們需要建立一個上下游關係。
```javascript
function createAnalyser(audio){
    // 設定音訊
    const AudioContext = window.AudioContext || window.webkitAudioContext; //相容性
    const audioCtx = new AudioContext();
    // 創建節點
    const source = audioCtx.createMediaElementSource(audio);
    const gainNode = audioCtx.createGain();
    const analyser = audioCtx.createAnalyser();
    // 連接節點
    source.connect(gainNode);
    gainNode.connect(analyser);
    analyser.connect(audioCtx.destination);
    // 對每個節點進行設定
    gainNode.gain.value = 1;
    analyser.fftSize = 1024; // frequencyBinCount = 512
    return analyser;
}
```
* createMediaElementSource：創建來源，用來連結 video 或 audio 元素
* connect：對每個結點來說，都需要藉此來連接輸入和輸出，可以想像成電路，透過串聯和並聯就能混音，達到不同的效果。
* fftSize：決定音頻數據的采樣數，值要設定成２的Ｎ次方，這個值越大就能捕捉到更細的頻率變化，屆時我們取得的陣列也越大。這裡也是性能考量的重點之一。
* frequencyBinCount：採樣設置為 1024 時，我們會得到其一半數量 512 條頻譜條。

Three 場景可以用來置入各種物體，方便渲染，這裡我們將長條圖的演算法用 BufferFactory 封裝，從音訊接口取得資料後，在交由 buff 去轉換成對應的圖形。這麼做可以讓程式碼之間更加獨立，音訊接口輸出音訊，演算法輸出長條圖。
```javascript
this.setCanvas = (canvas) => {
    //......
    this.buff = new BufferFactory();
    this.scene.add(this.buff.mesh)
}
this.update = () => {
    if(this.analyser){
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);

        const data = new Uint8Array(bufferLength / 2)
        for (let i = 0; i < bufferLength / 2; i++) {
            data[i] = dataArray[i];
        }
        this.buff.transformData(data);
        this.buff.update();
    }
}
```
* scene：用視覺化介面來比喻的話，就想像它是 Photoshop、PPT、Figma 中的圖層，可以合併不同圖片、用父子結構一層一層包裹，最後再一口氣放進場景。
* mesh：不管任何形狀都有的唯一實體，裡頭包裝了幾何位置、材質貼圖等等資訊。將其交給渲染器就能幫你將圖形渲染在畫布上。
* Uint8Array：它是一種型別化陣列，符合傳統陣列數據密集特性的結構，內存和分配相對高效。8位元意味著它是 0 ~ 255 的整數（無正負），適合處理音頻數據
* data：由於中高頻在 mp3 影響力較小，我個人習慣只取前面一半的陣列數，減低系統負擔

不知道你是否發現了彆腳的操作？

在粒子系統中，用同名函式來命名 update，用以引入各式各樣的演算法，這裡我們引入排序演算法（後續文章會提到）：
```javascript
class ParticleSystem{
    constructor(width, height){
        this.sort = new SortAlgorithm(); 
        //......this.walls, this.balls
    }
    update(){
        this.sort.update();
        this.balls.forEach((ball) => {
            // 碰撞檢測
        });
    }
    render(ctx){
        //......this.walls
        this.balls.forEach((ball) => {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI, false);
            ctx.fillStyle = "#FFFFFF";
            ctx.fill();
        });
    }
```
* 讓粒子系統獨立於狀態管理（ctx 和 canvas 元素），讓它有明確的初始化，並且採用類別建構式 Class。

結合引言，在粒子系統中，存有各式物件的資訊，可以直接進行繪圖和適當的分層渲染，不需要額外的繪圖工具。一個基本的球包含以下資訊：

```javascript
createBall(x, y, r){
    const vx = Math.random() * 100 - 50;
    const vy = Math.random() * 100 - 50;
    const ax = 0;
    const ay = 9.8 * 10;
    const ball = {x, y, r, vx, vy, ax, ay}
    return ball;
}
```

## **實作步驟**：
這個區塊會詳細說明如何進行碰撞檢測與響應，通過 JavaScript 來模擬粒子系統中的彈性碰撞。

### 粒子與粒子的碰撞檢測
在粒子系統中，粒子之間的碰撞是模擬彈性碰撞的核心部分。我們需要計算每一對粒子之間的距離，當距離小於兩者半徑之和時，表示兩個粒子發生碰撞，並需要根據動量和能量守恆原則來更新它們的速度。

在這裡，我們簡化問題，讓粒子之間的質量相同，並用了一個技巧，碰撞時用相對速度來取得能量的傳遞：
```javascript
handleBallCollision(ball, anotherBall, dist){
    const x = (ball.x + anotherBall.x) / 2;
    const y = (ball.y + anotherBall.y) / 2;

    // 更新球的位置以避免重疊
    ball.x = x + (ball.x - x) / (dist / 2) * ball.r;
    ball.y = y + (ball.y - y) / (dist / 2) * ball.r;
    anotherBall.x = x + (anotherBall.x - x) / (dist / 2) * anotherBall.r;
    anotherBall.y = y + (anotherBall.y - y) / (dist / 2) * anotherBall.r;

    // 相對速度
    const vx = (ball.vx - anotherBall.vx) / 2;
    const vy = (ball.vy - anotherBall.vy) / 2;

    // 計算碰撞後的相對速度
    const angle = Math.atan((ball.y - y) / (ball.x - x));
    const vectorT = -vx * Math.sin(angle) + vy * Math.cos(angle);
    const vectorN = -1 * (vx * Math.cos(angle) + vy * Math.sin(angle));
    const relativeX = -vectorT * Math.sin(angle) + vectorN * Math.cos(angle);
    const relativeY = vectorT * Math.cos(angle) + vectorN * Math.sin(angle);

    // 更新球的速度
    const averageVx = (ball.vx + anotherBall.vx) / 2;
    const averageVy = (ball.vy + anotherBall.vy) / 2;
    ball.vx = (averageVx + relativeX) * this.friction;
    ball.vy = (averageVy + relativeY) * this.friction;
    anotherBall.vx = (averageVx - relativeX) * this.friction;
    anotherBall.vy = (averageVy - relativeY) * this.friction;
}
```
* 避免球體重疊：當檢測到兩個球體重疊時，首先根據它們的中心點位置，重新計算球體的位置，避免物理模擬中的穿透現象。

* 計算速度變化：根據兩個球體的相對速度，我們計算其沿碰撞角度的切線與法線速度變化，從而更新它們的速度。這裡的 Math.atan 用於計算兩個球的相對位置角度，並通過三角運算分解速度。

* 速度更新：根據切線和法線速度，我們更新兩個球的最終速度，並乘以摩擦係數（friction）來模擬碰撞後能量損失。

### 粒子與牆壁的碰撞處理
牆壁方面，我們將形狀設計為弧形，因此可以視作和圓形的碰撞，主要目標是根據碰撞位置取得法線和切線方向，並根據這些方向更新粒子的速度，使其模擬反彈效果。
```javascript
    // 計算牆壁圓周上距離球體最近的點
    const x = wall.x + (ball.x - wall.x) / dist * wall.length;
    const y = wall.y + (ball.y - wall.y) / dist * wall.length;

    // 計算碰撞點的角度
    const atan = Math.atan((y - wall.y) / (x - wall.x)); // 第一第四象限
    const theta = atan > 0 ? atan : atan + Math.PI; // 第三第四象限
    const quadrant = y > wall.y ? theta : theta + Math.PI; // 一二三四象限

    // 判斷碰撞點是否在牆壁的弧形範圍內
    if (quadrant > wall.endAngle || quadrant < wall.startAngle) return;

    // 確定球體是否在牆壁內部或外部
    const isInside = dist <= wall.length ? 1 : -1;

    // 更新球體的位置，確保球體不會穿過牆壁
    ball.x = x + (ball.x - x) / (wall.length - dist) * (ball.r + wall.thick) * isInside;
    ball.y = y + (ball.y - y) / (wall.length - dist) * (ball.r + wall.thick) * isInside;

    // 計算反彈角度
    const angle = Math.atan((ball.y - y) / (ball.x - x));
    const vectorT = -ball.vx * Math.sin(angle) + ball.vy * Math.cos(angle);
    const vectorN = -1 * (ball.vx * Math.cos(angle) + ball.vy * Math.sin(angle));

    // 更新球體的速度，使其在碰撞後反彈
    ball.vx = (-vectorT * Math.sin(angle) + vectorN * Math.cos(angle)) * this.friction;
    ball.vy = (vectorT * Math.cos(angle) + vectorN * Math.sin(angle)) * this.friction;
}
```
### update 逐禎更新
在每一幀中，必須依次更新所有粒子的速度和位置，並進行碰撞檢測。
```javascript
this.balls.forEach((ball) => {
    // 更新速度和位置
    ball.x = (ball.x + ball.vx / 60);
    ball.y = (ball.y + ball.vy / 60);
    ball.vx = (ball.vx + ball.ax / 60) * this.slow;
    ball.vy = (ball.vy + ball.ay / 60) * this.slow;
    // 檢測與其他球體的碰撞
    this.balls.forEach((anotherBall) => {
        if (ball == anotherBall) return;
        const dist = this.getDist(ball, anotherBall);
        if (dist < ball.r + anotherBall.r) {
            this.handleBallCollision(ball, anotherBall, dist);
        }
    });

    // 檢測與牆壁的碰撞
    this.walls.forEach((wall) => {
        const dist = this.getCollide(ball, wall);
        if (dist > 0) {
            this.handleWallCollision(ball, wall, dist);
        }
    });
});
```

以及用來取得距離、檢測碰撞的函式：
```javascript
getDist(a, b){
    const x = a.x - b.x;
    const y = a.y - b.y;
    const dist = Math.sqrt(x*x + y*y);
    return dist;
}
getCollide(ball, wall){
    if(wall.type == "arc"){
        const x = ball.x - wall.x;
        const y = ball.y - wall.y;
        const dist = Math.sqrt(x*x + y*y);
        return (dist + ball.r >= wall.length - wall.thick && dist < wall.length + wall.thick) ? dist : 0; 
    }
    return 0;
}
```

### **結論**
在這篇文章中，我們探討了如何在粒子系統中模擬彈性碰撞，包括粒子之間的碰撞檢測與處理，以及粒子與牆壁的碰撞處理。透過每一幀更新位置和速度，並在必要時進行碰撞處理，我們能夠創建一個具有物理真實感的粒子系統。

在優化和擴展方面，我們可以進一步加入更真實的物理參數，如質量、彈性系數，甚至考慮流體力學和引力效應。最終，我們所建立的系統不僅僅是一個動畫展示，更是一個結合數學、物理與程式設計的實踐項目，展現了粒子系統在動畫與模擬中的廣泛應用。